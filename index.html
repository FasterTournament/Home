<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guild Live - Voice & Stream</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #0d141f; font-family: sans-serif; color: white; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .banner { width: 100%; height: 230px; background: #000; border-bottom: 1px solid #1c2a3a; }
        #ytPlayer { width: 100%; height: 100%; border: none; }
        .content { flex: 1; padding: 15px; overflow-y: auto; }
        .user-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; }
        .user-card { background-color: #162130; border-radius: 12px; padding: 10px; display: flex; align-items: center; border: 1px solid rgba(255,255,255,0.05); }
        .avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background: #2d3748; display: flex; align-items: center; justify-content: center; border: 2px solid transparent; }
        .voice-active { border-color: #3b82f6 !important; animation: pulse 0.6s infinite alternate; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.6); } 100% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); } }
        .controls { display: flex; justify-content: space-around; padding: 20px 10px; background-color: #0d141f; border-top: 1px solid #1c2a3a; }
        .control-btn { display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; background: none; border: none; color: #94a3b8; outline: none; }
        .icon-circle { width: 52px; height: 52px; border-radius: 50%; background-color: #2d3748; display: flex; align-items: center; justify-content: center; font-size: 18px; color: white; }
        .active .icon-circle { background-color: #3b82f6; }
        .btn-red .icon-circle { background-color: #ef4444; }
        
        /* Status indicator */
        .status-indicator {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
            background: #374151;
            margin-top: 3px;
            display: inline-block;
        }
        
        .status-connected {
            background: #10b981;
        }
        
        .status-muted {
            background: #6b7280;
        }
        
        .status-speaking {
            background: #3b82f6;
        }
    </style>
</head>
<body>

    <div class="banner" id="videoContainer"></div>

    <div class="content">
        <div class="user-list" id="userList">
            <div style="text-align: center; padding: 20px; color: #94a3b8;">
                <i class="fas fa-spinner fa-spin"></i> Loading...
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-btn active" id="speakerBtn"><div class="icon-circle"><i class="fas fa-volume-up"></i></div><span>Speaker</span></button>
        <button class="control-btn" id="micBtn"><div class="icon-circle"><i class="fas fa-microphone-slash" id="micIcon"></i></div><span id="micText">Unmute</span></button>
        <button class="control-btn btn-red" id="leaveBtn"><div class="icon-circle"><i class="fas fa-phone-slash"></i></div><span>Leave</span></button>
    </div>

    <script>
        const config = {
            apiKey: "AIzaSyCSoTqqSC_NqigWrHwE4Q8IUvWRP9TrxG8",
            databaseURL: "https://top-up-4db01-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "top-up-4db01",
            appId: "1:264548197473:android:4c986618c48182125d7620"
        };
        
        firebase.initializeApp(config);
        const db = firebase.database();
        const myId = "User_" + Math.floor(Math.random() * 9000 + 1000);
        let localStream;
        const peers = {};
        const processedSignals = new Set();
        const activeConnections = new Set();
        const audioElements = {};

        // ১. ইউটিউব লাইভ
        db.ref('live_stream/video_id').on('value', snap => {
            if(snap.val()) {
                document.getElementById('videoContainer').innerHTML = `<iframe id="ytPlayer" src="https://www.youtube.com/embed/${snap.val()}?autoplay=1&mute=0"></iframe>`;
            } else {
                document.getElementById('videoContainer').innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #94a3b8;">
                        <div style="text-align: center;">
                            <i class="fas fa-video-slash" style="font-size: 40px; margin-bottom: 10px;"></i>
                            <p>No live stream active</p>
                        </div>
                    </div>
                `;
            }
        });

        // ২. অডিও এবং সিগন্যালিং শুরু
        async function startApp() {
            try {
                console.log("Starting app...");
                
                // Try to get microphone access
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                console.log("Microphone access granted");
                
                // শুরুতে মিউট
                localStream.getAudioTracks()[0].enabled = false;
                
                // Cleanup any existing data
                db.ref('users/' + myId).remove();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Set user data
                await db.ref('users/' + myId).set({ 
                    id: myId, 
                    isMuted: true,
                    timestamp: Date.now()
                });
                
                console.log("User data saved:", myId);
                
                // Cleanup on disconnect
                db.ref('users/' + myId).onDisconnect().remove();
                
                // Listen for existing users
                setupUserListeners();
                
                // Setup signal listener
                setupSignalListener();
                
                // Initial connection to existing users
                connectToExistingUsers();
                
            } catch (error) {
                console.error("Error starting app:", error);
                document.getElementById('userList').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #ef4444;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 40px; margin-bottom: 15px;"></i>
                        <p>Error: ${error.message}</p>
                        <button onclick="location.reload()" style="margin-top: 15px; padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Refresh Page
                        </button>
                    </div>
                `;
            }
        }

        function setupUserListeners() {
            // নতুন user যোগদান
            db.ref('users').on('child_added', snapshot => {
                const user = snapshot.val();
                console.log("User added:", user.id);
                
                if (user.id !== myId && !peers[user.id] && !activeConnections.has(user.id)) {
                    activeConnections.add(user.id);
                    setTimeout(() => initiateCall(user.id), 1000);
                }
            });

            // User remove হলে cleanup
            db.ref('users').on('child_removed', snapshot => {
                const userId = snapshot.key;
                console.log("User removed:", userId);
                
                cleanupPeer(userId);
                activeConnections.delete(userId);
            });
        }

        function setupSignalListener() {
            db.ref('signals/' + myId).on('child_added', snapshot => {
                const signal = snapshot.val();
                const signalKey = snapshot.key;
                
                console.log("Signal received from:", signal?.from, "key:", signalKey);
                
                if(!signal || !signal.from || signal.from === myId) {
                    db.ref('signals/' + myId).child(signalKey).remove();
                    return;
                }
                
                if(processedSignals.has(signalKey)) {
                    db.ref('signals/' + myId).child(signalKey).remove();
                    return;
                }
                
                processedSignals.add(signalKey);
                handleSignal(signal, signalKey);
            });
        }

        async function connectToExistingUsers() {
            const snapshot = await db.ref('users').once('value');
            const users = snapshot.val();
            
            if(!users) return;
            
            console.log("Existing users:", Object.keys(users));
            
            // Connect to all existing users except myself
            for(let id in users) {
                if(users[id].id !== myId && !peers[users[id].id] && !activeConnections.has(users[id].id)) {
                    console.log("Connecting to existing user:", users[id].id);
                    activeConnections.add(users[id].id);
                    setTimeout(() => initiateCall(users[id].id), 500);
                }
            }
        }

        function initiateCall(targetId) {
            if(peers[targetId] || !localStream) {
                console.log("Skipping call to", targetId, "- already connected or no stream");
                return;
            }
            
            console.log("Initiating call to:", targetId);
            
            const peer = new SimplePeer({ 
                initiator: true, 
                trickle: false, 
                stream: localStream,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('signal', data => {
                console.log("Sending signal to:", targetId);
                db.ref('signals/' + targetId).push({ 
                    from: myId, 
                    signal: data 
                }).then(ref => {
                    setTimeout(() => ref.remove(), 15000);
                });
            });
            
            peer.on('stream', stream => {
                console.log("Received stream from:", targetId);
                playRemoteStream(stream, targetId);
            });
            
            peer.on('error', err => {
                console.error('Peer error for', targetId, ':', err);
                cleanupPeer(targetId);
            });
            
            peer.on('close', () => {
                console.log("Peer closed for:", targetId);
                cleanupPeer(targetId);
            });
            
            peer.on('connect', () => {
                console.log("✅ Connected to:", targetId);
                updateConnectionStatus(targetId, true);
            });
            
            peer.on('data', data => {
                console.log("Data received from", targetId, ":", data);
            });
            
            peers[targetId] = peer;
        }

        function handleSignal(data, signalKey) {
            console.log("Handling signal from:", data.from);
            
            if(!data || !data.from || !data.signal) {
                db.ref('signals/' + myId).child(signalKey).remove();
                return;
            }

            let peer = peers[data.from];
            
            if (!peer) {
                console.log("Creating peer for:", data.from);
                
                peer = new SimplePeer({ 
                    initiator: false, 
                    trickle: false, 
                    stream: localStream,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' }
                        ]
                    }
                });
                
                peer.on('signal', signalData => {
                    console.log("Responding to signal from:", data.from);
                    db.ref('signals/' + data.from).push({ 
                        from: myId, 
                        signal: signalData 
                    }).then(ref => {
                        setTimeout(() => ref.remove(), 15000);
                    });
                });
                
                peer.on('stream', stream => {
                    console.log("✅ Stream received from responder:", data.from);
                    playRemoteStream(stream, data.from);
                });
                
                peer.on('error', err => {
                    console.error('Responder peer error:', err);
                    cleanupPeer(data.from);
                });
                
                peer.on('close', () => {
                    console.log("Responder peer closed:", data.from);
                    cleanupPeer(data.from);
                });
                
                peer.on('connect', () => {
                    console.log("✅ Responder connected:", data.from);
                    updateConnectionStatus(data.from, true);
                });
                
                peers[data.from] = peer;
                activeConnections.add(data.from);
            }
            
            try {
                console.log("Applying signal from:", data.from);
                peer.signal(data.signal);
            } catch(err) {
                console.error('Error applying signal:', err);
            }
            
            setTimeout(() => {
                db.ref('signals/' + myId).child(signalKey).remove();
                processedSignals.delete(signalKey);
            }, 1000);
        }

        function playRemoteStream(stream, userId) {
            console.log("Playing stream for:", userId);
            
            let audio = audioElements[userId];
            if(!audio) {
                audio = document.createElement('audio');
                audio.id = 'audio-' + userId;
                audio.autoplay = true;
                audio.volume = 1.0;
                audio.setAttribute('data-user', userId);
                document.body.appendChild(audio);
                audioElements[userId] = audio;
            }
            
            try {
                audio.srcObject = stream;
                console.log("✅ Audio stream set for:", userId);
            } catch(e) {
                console.error('Error setting audio source:', e);
            }
        }

        function cleanupPeer(userId) {
            console.log("Cleaning up peer:", userId);
            
            if(peers[userId]) {
                try {
                    peers[userId].destroy();
                } catch(e) {
                    console.log("Error destroying peer:", e);
                }
                delete peers[userId];
            }
            
            if(audioElements[userId]) {
                try {
                    audioElements[userId].pause();
                    audioElements[userId].srcObject = null;
                    audioElements[userId].remove();
                } catch(e) {}
                delete audioElements[userId];
            }
            
            activeConnections.delete(userId);
            
            for(const key of processedSignals) {
                if(key.includes(userId)) {
                    processedSignals.delete(key);
                }
            }
            
            updateConnectionStatus(userId, false);
        }

        function updateConnectionStatus(userId, connected) {
            // This function updates UI to show connection status
            const userCards = document.querySelectorAll('.user-card');
            userCards.forEach(card => {
                const nameElement = card.querySelector('.user-name');
                if(nameElement && nameElement.textContent.includes(userId)) {
                    const statusSpan = card.querySelector('.connection-status');
                    if(statusSpan) {
                        statusSpan.textContent = connected ? 'Connected' : 'Disconnected';
                        statusSpan.className = `status-indicator ${connected ? 'status-connected' : ''}`;
                    }
                }
            });
        }

        // ৩. বাটন কন্ট্রোল
        document.getElementById('micBtn').onclick = () => {
            if(!localStream || localStream.getAudioTracks().length === 0) {
                alert("Microphone not available. Please refresh the page.");
                return;
            }
            
            const audioTrack = localStream.getAudioTracks()[0];
            const isCurrentlyEnabled = audioTrack.enabled;
            const newState = !isCurrentlyEnabled;
            
            audioTrack.enabled = newState;
            
            document.getElementById('micBtn').classList.toggle('active', newState);
            document.getElementById('micIcon').className = newState ? 'fas fa-microphone' : 'fas fa-microphone-slash';
            document.getElementById('micText').innerText = newState ? 'Mute' : 'Unmute';
            
            db.ref('users/' + myId).update({ 
                isMuted: !newState,
                timestamp: Date.now()
            });
            
            console.log("Mic state changed to:", newState ? "Unmuted" : "Muted");
        };

        // User list update - FIXED version
        db.ref('users').on('value', snap => {
            const users = snap.val();
            const list = document.getElementById('userList');
            
            if(!users) {
                list.innerHTML = '<div style="text-align: center; padding: 20px; color: #94a3b8;">No users online</div>';
                return;
            }
            
            let html = '';
            const userArray = Object.values(users);
            const realUserCount = userArray.length;
            
            console.log("Real user count:", realUserCount, "Users:", userArray.map(u => u.id));
            
            // Sort: Me first, then others
            userArray.sort((a, b) => {
                if(a.id === myId) return -1;
                if(b.id === myId) return 1;
                return (b.timestamp || 0) - (a.timestamp || 0);
            });
            
            userArray.forEach(u => {
                const isMe = u.id === myId;
                const isSpeaking = !u.isMuted;
                const isConnected = peers[u.id] && peers[u.id].connected;
                
                html += `
                    <div class="user-card">
                        <div class="avatar ${isSpeaking ? 'voice-active' : ''}">
                            <i class="fas fa-user"></i>
                        </div>
                        <div class="user-name">
                            <strong>${isMe ? 'You (Me)' : u.id}</strong><br>
                            <span class="status-indicator ${isConnected ? 'status-connected' : ''}">
                                ${isMe ? 'Me' : (isConnected ? 'Connected' : 'Connecting...')}
                            </span>
                            <span class="status-indicator ${isSpeaking ? 'status-speaking' : 'status-muted'}">
                                ${isSpeaking ? 'Speaking' : 'Muted'}
                            </span>
                        </div>
                    </div>
                `;
            });
            
            list.innerHTML = html;
            
            // Update title with real count
            document.title = `Guild Live (${realUserCount} Online)`;
        });

        document.getElementById('leaveBtn').onclick = () => {
            if(confirm("Are you sure you want to leave the voice chat?")) {
                // Cleanup all peers
                for(const userId in peers) {
                    cleanupPeer(userId);
                }
                
                // Stop local stream
                if(localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Remove from Firebase
                db.ref('users/' + myId).remove();
                db.ref('signals/' + myId).remove();
                
                // Redirect after cleanup
                setTimeout(() => {
                    window.location.href = window.location.href;
                }, 500);
            }
        };

        // Speaker button control
        document.getElementById('speakerBtn').onclick = () => {
            const btn = document.getElementById('speakerBtn');
            const isActive = btn.classList.contains('active');
            
            if(isActive) {
                btn.classList.remove('active');
                document.querySelector('#speakerBtn .icon-circle i').className = 'fas fa-volume-mute';
                
                Object.values(audioElements).forEach(audio => {
                    audio.volume = 0;
                });
                
                console.log("All speakers muted");
            } else {
                btn.classList.add('active');
                document.querySelector('#speakerBtn .icon-circle i').className = 'fas fa-volume-up';
                
                Object.values(audioElements).forEach(audio => {
                    audio.volume = 1.0;
                });
                
                console.log("Speakers unmuted");
            }
        };

        // Auto cleanup on page unload
        window.addEventListener('beforeunload', (e) => {
            db.ref('users/' + myId).remove();
            db.ref('signals/' + myId).remove();
            
            if(localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        });

        // Debug info
        console.log("My ID:", myId);
        console.log("Starting app...");
        
        startApp();
    </script>
</body>
</html>
