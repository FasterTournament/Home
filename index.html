<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guild Live - Voice & Stream</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background-color: #0d141f; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            color: white; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
        }
        
        .banner { 
            width: 100%; 
            height: 230px; 
            background: linear-gradient(135deg, #1a2536 0%, #0d141f 100%);
            border-bottom: 1px solid #1c2a3a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .connection-info {
            text-align: center;
            padding: 20px;
        }
        
        .connection-info h2 {
            color: #3b82f6;
            margin-bottom: 10px;
            font-size: 24px;
        }
        
        .connection-status {
            font-size: 14px;
            color: #94a3b8;
        }
        
        .connected {
            color: #10b981 !important;
            font-weight: bold;
        }
        
        .content { 
            flex: 1; 
            padding: 15px; 
            overflow-y: auto; 
        }
        
        .user-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); 
            gap: 12px; 
        }
        
        .user-card { 
            background-color: #162130; 
            border-radius: 12px; 
            padding: 12px; 
            display: flex; 
            align-items: center; 
            border: 1px solid rgba(255,255,255,0.05);
            transition: all 0.3s ease;
        }
        
        .user-card:hover {
            transform: translateY(-2px);
            border-color: rgba(59, 130, 246, 0.3);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .avatar { 
            width: 45px; 
            height: 45px; 
            border-radius: 50%; 
            margin-right: 12px; 
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            display: flex; 
            align-items: center; 
            justify-content: center; 
            border: 2px solid transparent; 
            font-size: 18px;
        }
        
        .voice-active { 
            border-color: #3b82f6 !important; 
            animation: pulse 1s infinite alternate; 
        }
        
        @keyframes pulse { 
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.6); } 
            100% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); } 
        }
        
        .user-info {
            flex: 1;
        }
        
        .user-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }
        
        .user-status {
            font-size: 12px;
            color: #94a3b8;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .status-online {
            background-color: #10b981;
        }
        
        .status-speaking {
            background-color: #3b82f6;
            animation: pulse 1s infinite;
        }
        
        .status-muted {
            background-color: #ef4444;
        }
        
        .controls { 
            display: flex; 
            justify-content: space-around; 
            padding: 20px 10px; 
            background: linear-gradient(to top, #0d141f, #1a2536);
            border-top: 1px solid #1c2a3a; 
        }
        
        .control-btn { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 8px; 
            cursor: pointer; 
            background: none; 
            border: none; 
            color: #94a3b8; 
            outline: none; 
            transition: all 0.3s ease;
            min-width: 80px;
        }
        
        .control-btn:hover:not(:disabled) {
            color: #ffffff;
            transform: scale(1.05);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .icon-circle { 
            width: 60px; 
            height: 60px; 
            border-radius: 50%; 
            background: linear-gradient(135deg, #2d3748, #1a2536);
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 20px; 
            color: white; 
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .control-btn.active .icon-circle { 
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }
        
        .btn-red .icon-circle { 
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }
        
        .btn-red:hover:not(:disabled) .icon-circle {
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }
        
        .loading {
            text-align: center;
            padding: 30px;
            color: #94a3b8;
            font-size: 16px;
        }
        
        .loading i {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            color: #94a3b8;
            max-width: 200px;
            display: none;
        }
        
        .show-debug {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 1px solid #3b82f6;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
    </style>
</head>
<body>

    <div class="banner" id="videoContainer">
        <div class="connection-info">
            <h2>Guild Live Voice Chat</h2>
            <p class="connection-status" id="connectionStatus">Connecting...</p>
            <p class="connection-status" id="userId">ID: Loading...</p>
        </div>
    </div>

    <div class="content">
        <div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="color: #3b82f6;">Voice Participants</h3>
            <span id="userCount" style="background: #3b82f6; padding: 5px 12px; border-radius: 15px; font-size: 14px; font-weight: bold;">0 Online</span>
        </div>
        <div class="user-list" id="userList">
            <div class="loading">
                <i class="fas fa-spinner fa-spin"></i><br>
                Loading users...
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-btn active" id="speakerBtn">
            <div class="icon-circle"><i class="fas fa-volume-up"></i></div>
            <span>Speaker</span>
        </button>
        <button class="control-btn" id="micBtn">
            <div class="icon-circle"><i class="fas fa-microphone-slash" id="micIcon"></i></div>
            <span id="micText">Unmute</span>
        </button>
        <button class="control-btn btn-red" id="leaveBtn">
            <div class="icon-circle"><i class="fas fa-phone-slash"></i></div>
            <span>Leave</span>
        </button>
    </div>

    <button class="show-debug" onclick="toggleDebug()">Debug Info</button>
    <div class="debug-info" id="debugInfo">
        <div><strong>Debug Information</strong></div>
        <div>Local Stream: <span id="debugStream">No</span></div>
        <div>Mic Enabled: <span id="debugMic">No</span></div>
        <div>Peers: <span id="debugPeers">0</span></div>
        <div>Audio Elements: <span id="debugAudio">0</span></div>
    </div>

    <script>
        // Debug mode
        const DEBUG = true;
        
        class SimpleVoiceChat {
            constructor() {
                this.myId = 'User_' + Math.floor(Math.random() * 9000 + 1000);
                this.localStream = null;
                this.peers = {};
                this.users = {};
                this.audioElements = {};
                this.isMuted = true;
                this.isSpeaking = false;
                this.connectedUsers = new Set();
                
                this.init();
            }
            
            async init() {
                console.log('ðŸŽ¤ Initializing Voice Chat...');
                console.log('Your ID:', this.myId);
                
                this.updateStatus('Initializing...');
                document.getElementById('userId').textContent = `ID: ${this.myId}`;
                
                try {
                    // Get microphone permission
                    await this.getMicrophoneAccess();
                    
                    // Setup UI controls
                    this.setupControls();
                    
                    // Update UI
                    this.updateUI();
                    
                    // Start peer discovery simulation
                    this.startPeerDiscovery();
                    
                    this.updateStatus('Ready to connect');
                    
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.updateStatus('Error: ' + error.message, 'error');
                    this.showError('Failed to initialize voice chat');
                }
            }
            
            async getMicrophoneAccess() {
                try {
                    console.log('Requesting microphone access...');
                    
                    // Try to get microphone
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            channelCount: 1
                        },
                        video: false
                    });
                    
                    console.log('âœ… Microphone access granted');
                    
                    // Start muted
                    this.localStream.getAudioTracks()[0].enabled = false;
                    this.isMuted = true;
                    
                    this.updateDebugInfo();
                    
                } catch (error) {
                    console.error('âŒ Microphone access denied:', error);
                    throw new Error('Microphone access required for voice chat');
                }
            }
            
            setupControls() {
                const micBtn = document.getElementById('micBtn');
                const speakerBtn = document.getElementById('speakerBtn');
                const leaveBtn = document.getElementById('leaveBtn');
                
                // Mic Button - FIXED VERSION
                micBtn.addEventListener('click', () => {
                    console.log('Mic button clicked');
                    this.toggleMicrophone();
                });
                
                // Speaker Button
                speakerBtn.addEventListener('click', () => {
                    this.toggleSpeaker();
                });
                
                // Leave Button
                leaveBtn.addEventListener('click', () => {
                    if (confirm('Are you sure you want to leave?')) {
                        this.leaveChat();
                    }
                });
                
                console.log('âœ… Controls setup complete');
            }
            
            toggleMicrophone() {
                if (!this.localStream || this.localStream.getAudioTracks().length === 0) {
                    console.error('No local stream available');
                    this.showError('Microphone not available');
                    return;
                }
                
                try {
                    const audioTrack = this.localStream.getAudioTracks()[0];
                    const currentState = audioTrack.enabled;
                    const newState = !currentState;
                    
                    console.log('Toggling microphone:', {
                        current: currentState ? 'Enabled' : 'Disabled',
                        new: newState ? 'Enabled' : 'Disabled'
                    });
                    
                    // Update track state
                    audioTrack.enabled = newState;
                    this.isMuted = !newState;
                    
                    // Update UI
                    const micBtn = document.getElementById('micBtn');
                    const micIcon = document.getElementById('micIcon');
                    const micText = document.getElementById('micText');
                    
                    if (newState) {
                        // Mic is now ON
                        micBtn.classList.add('active');
                        micIcon.className = 'fas fa-microphone';
                        micText.textContent = 'Mute';
                        console.log('ðŸŽ¤ Microphone UNMUTED');
                    } else {
                        // Mic is now OFF
                        micBtn.classList.remove('active');
                        micIcon.className = 'fas fa-microphone-slash';
                        micText.textContent = 'Unmute';
                        console.log('ðŸ”‡ Microphone MUTED');
                    }
                    
                    this.updateUI();
                    this.updateDebugInfo();
                    
                    // Simulate broadcast to other users (in a real app, this would go through a server)
                    this.broadcastMicState();
                    
                } catch (error) {
                    console.error('Error toggling microphone:', error);
                    this.showError('Failed to toggle microphone');
                }
            }
            
            toggleSpeaker() {
                const speakerBtn = document.getElementById('speakerBtn');
                const isActive = speakerBtn.classList.contains('active');
                
                if (isActive) {
                    // Mute all speakers
                    speakerBtn.classList.remove('active');
                    document.querySelector('#speakerBtn .icon-circle i').className = 'fas fa-volume-mute';
                    
                    Object.values(this.audioElements).forEach(audio => {
                        audio.volume = 0;
                    });
                    
                    console.log('ðŸ”‡ All speakers muted');
                } else {
                    // Unmute all speakers
                    speakerBtn.classList.add('active');
                    document.querySelector('#speakerBtn .icon-circle i').className = 'fas fa-volume-up';
                    
                    Object.values(this.audioElements).forEach(audio => {
                        audio.volume = 1.0;
                    });
                    
                    console.log('ðŸ”Š All speakers unmuted');
                }
            }
            
            startPeerDiscovery() {
                console.log('Starting peer discovery simulation...');
                
                // Simulate finding other users
                setInterval(() => {
                    this.simulateUserDiscovery();
                }, 3000);
                
                // Simulate incoming connections
                setInterval(() => {
                    this.simulateIncomingConnections();
                }, 5000);
            }
            
            simulateUserDiscovery() {
                // In a real app, this would be from a server
                // For demo, we'll simulate some users
                const simulatedUsers = [
                    'User_' + Math.floor(Math.random() * 9000 + 1000),
                    'User_' + Math.floor(Math.random() * 9000 + 1000)
                ];
                
                simulatedUsers.forEach(userId => {
                    if (userId !== this.myId && !this.users[userId]) {
                        this.addUser(userId, Math.random() > 0.5);
                        
                        // Simulate connection
                        setTimeout(() => {
                            this.connectToUser(userId);
                        }, 1000);
                    }
                });
            }
            
            simulateIncomingConnections() {
                // Simulate some users disconnecting
                Object.keys(this.users).forEach(userId => {
                    if (Math.random() > 0.8 && userId !== this.myId) {
                        this.removeUser(userId);
                    }
                });
            }
            
            addUser(userId, isMuted = true) {
                if (!this.users[userId] && userId !== this.myId) {
                    this.users[userId] = {
                        id: userId,
                        isMuted: isMuted,
                        connected: false,
                        speaking: false
                    };
                    
                    this.connectedUsers.add(userId);
                    console.log('âž• User added:', userId);
                    this.updateUI();
                }
            }
            
            removeUser(userId) {
                if (this.users[userId]) {
                    // Cleanup peer
                    if (this.peers[userId]) {
                        this.peers[userId].destroy();
                        delete this.peers[userId];
                    }
                    
                    // Cleanup audio
                    if (this.audioElements[userId]) {
                        this.audioElements[userId].pause();
                        this.audioElements[userId].srcObject = null;
                        this.audioElements[userId].remove();
                        delete this.audioElements[userId];
                    }
                    
                    // Remove from users
                    delete this.users[userId];
                    this.connectedUsers.delete(userId);
                    
                    console.log('âž– User removed:', userId);
                    this.updateUI();
                }
            }
            
            async connectToUser(userId) {
                if (this.peers[userId] || userId === this.myId || !this.localStream) {
                    return;
                }
                
                console.log('ðŸ”— Connecting to:', userId);
                
                try {
                    const peer = new SimplePeer({
                        initiator: true,
                        trickle: true,
                        stream: this.localStream,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' },
                                { urls: 'stun:stun2.l.google.com:19302' }
                            ]
                        }
                    });
                    
                    peer.on('signal', (signal) => {
                        console.log('ðŸ“¡ Signal generated for:', userId);
                        // In a real app, send this to signaling server
                    });
                    
                    peer.on('stream', (stream) => {
                        console.log('ðŸŽµ Stream received from:', userId);
                        this.handleRemoteStream(userId, stream);
                    });
                    
                    peer.on('connect', () => {
                        console.log('âœ… Connected to:', userId);
                        if (this.users[userId]) {
                            this.users[userId].connected = true;
                            this.updateUI();
                        }
                    });
                    
                    peer.on('error', (err) => {
                        console.error('âŒ Peer error:', err);
                        this.removeUser(userId);
                    });
                    
                    peer.on('close', () => {
                        console.log('ðŸ”’ Connection closed with:', userId);
                        this.removeUser(userId);
                    });
                    
                    this.peers[userId] = peer;
                    
                } catch (error) {
                    console.error('Connection error:', error);
                }
            }
            
            handleRemoteStream(userId, stream) {
                console.log('ðŸŽ§ Playing stream from:', userId);
                
                let audio = this.audioElements[userId];
                if (!audio) {
                    audio = document.createElement('audio');
                    audio.id = 'audio-' + userId;
                    audio.autoplay = true;
                    audio.volume = document.getElementById('speakerBtn').classList.contains('active') ? 1.0 : 0;
                    audio.setAttribute('data-user', userId);
                    document.body.appendChild(audio);
                    this.audioElements[userId] = audio;
                }
                
                audio.srcObject = stream;
                
                // Update user status
                if (this.users[userId]) {
                    this.users[userId].connected = true;
                    this.users[userId].speaking = true;
                    this.updateUI();
                }
                
                this.updateDebugInfo();
            }
            
            broadcastMicState() {
                // In a real app, broadcast to other users through server
                console.log('Broadcasting mic state:', this.isMuted ? 'MUTED' : 'UNMUTED');
                
                // Update all connected users
                Object.keys(this.users).forEach(userId => {
                    if (this.users[userId]) {
                        this.users[userId].speaking = !this.isMuted;
                    }
                });
                
                this.updateUI();
            }
            
            updateUI() {
                const userList = document.getElementById('userList');
                const userCount = document.getElementById('userCount');
                
                // Always include myself
                const allUsers = {
                    [this.myId]: {
                        id: this.myId,
                        isMuted: this.isMuted,
                        connected: true,
                        speaking: !this.isMuted
                    },
                    ...this.users
                };
                
                const usersArray = Object.values(allUsers);
                const onlineCount = usersArray.length;
                
                userCount.textContent = `${onlineCount} Online`;
                
                if (usersArray.length === 1 && usersArray[0].id === this.myId) {
                    userList.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #94a3b8;">
                            <i class="fas fa-users" style="font-size: 40px; margin-bottom: 15px;"></i>
                            <p>Waiting for other users to join...</p>
                            <p style="font-size: 12px; margin-top: 10px;">Your ID: ${this.myId}</p>
                        </div>
                    `;
                    return;
                }
                
                let html = '';
                usersArray.forEach(user => {
                    const isMe = user.id === this.myId;
                    const isSpeaking = user.speaking && user.connected;
                    
                    html += `
                        <div class="user-card">
                            <div class="avatar ${isSpeaking ? 'voice-active' : ''}">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="user-info">
                                <div class="user-name">
                                    ${isMe ? 'You (Me)' : user.id}
                                </div>
                                <div class="user-status">
                                    ${isMe ? (this.isMuted ? 'Muted' : 'Speaking') : 
                                      (user.connected ? (isSpeaking ? 'Speaking' : 'Muted') : 'Connecting...')}
                                </div>
                            </div>
                            <div class="status-dot ${isSpeaking ? 'status-speaking' : 
                                (isMe ? (this.isMuted ? 'status-muted' : 'status-speaking') : 
                                (user.connected ? 'status-online' : 'status-muted'))}"></div>
                        </div>
                    `;
                });
                
                userList.innerHTML = html;
            }
            
            updateStatus(message, type = 'info') {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.textContent = message;
                
                if (type === 'error') {
                    statusEl.style.color = '#ef4444';
                } else if (type === 'success') {
                    statusEl.style.color = '#10b981';
                } else {
                    statusEl.style.color = '#3b82f6';
                }
            }
            
            updateDebugInfo() {
                if (!DEBUG) return;
                
                document.getElementById('debugStream').textContent = this.localStream ? 'Yes' : 'No';
                document.getElementById('debugMic').textContent = this.localStream && 
                    this.localStream.getAudioTracks()[0]?.enabled ? 'Yes' : 'No';
                document.getElementById('debugPeers').textContent = Object.keys(this.peers).length;
                document.getElementById('debugAudio').textContent = Object.keys(this.audioElements).length;
            }
            
            showError(message) {
                alert(message);
            }
            
            leaveChat() {
                console.log('Leaving chat...');
                
                // Cleanup all connections
                Object.keys(this.peers).forEach(userId => {
                    this.removeUser(userId);
                });
                
                // Stop local stream
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }
                
                this.updateStatus('Disconnected');
                
                // Reload page after a delay
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }
        }
        
        function toggleDebug() {
            const debugInfo = document.getElementById('debugInfo');
            debugInfo.style.display = debugInfo.style.display === 'block' ? 'none' : 'block';
        }
        
        // Start voice chat when page loads
        window.addEventListener('load', () => {
            console.log('ðŸš€ Starting Guild Live Voice Chat...');
            window.voiceChat = new SimpleVoiceChat();
        });
        
        // Prevent accidental page leave
        window.addEventListener('beforeunload', (e) => {
            if (window.voiceChat && Object.keys(window.voiceChat.peers).length > 0) {
                e.preventDefault();
                e.returnValue = 'Are you sure you want to leave the voice chat?';
            }
        });
    </script>
</body>
</html>
