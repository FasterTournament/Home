<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guild Live - Voice & Stream</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #0d141f; font-family: sans-serif; color: white; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .banner { width: 100%; height: 230px; background: #000; border-bottom: 1px solid #1c2a3a; }
        #ytPlayer { width: 100%; height: 100%; border: none; }
        .content { flex: 1; padding: 15px; overflow-y: auto; }
        .user-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; }
        .user-card { background-color: #162130; border-radius: 12px; padding: 10px; display: flex; align-items: center; border: 1px solid rgba(255,255,255,0.05); }
        .avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background: #2d3748; display: flex; align-items: center; justify-content: center; border: 2px solid transparent; }
        .voice-active { border-color: #3b82f6 !important; animation: pulse 0.6s infinite alternate; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.6); } 100% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); } }
        .controls { display: flex; justify-content: space-around; padding: 20px 10px; background-color: #0d141f; border-top: 1px solid #1c2a3a; }
        .control-btn { display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; background: none; border: none; color: #94a3b8; outline: none; }
        .icon-circle { width: 52px; height: 52px; border-radius: 50%; background-color: #2d3748; display: flex; align-items: center; justify-content: center; font-size: 18px; color: white; }
        .active .icon-circle { background-color: #3b82f6; }
        .btn-red .icon-circle { background-color: #ef4444; }
        
        .status-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-top: 3px;
            display: inline-block;
        }
        .connected { background: #10b981; }
        .disconnected { background: #6b7280; }
        .speaking { background: #3b82f6; }
        .muted { background: #ef4444; }
    </style>
</head>
<body>

    <div class="banner" id="videoContainer">
        <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #94a3b8;">
            <div style="text-align: center;">
                <i class="fas fa-broadcast-tower" style="font-size: 40px; margin-bottom: 10px;"></i>
                <p>Guild Live Voice Chat</p>
                <p style="font-size: 14px; margin-top: 5px;" id="connectionStatus">Connecting...</p>
            </div>
        </div>
    </div>

    <div class="content">
        <div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
            <h3>Voice Participants</h3>
            <span id="userCount" style="background: #3b82f6; padding: 3px 10px; border-radius: 15px; font-size: 14px;">0 Online</span>
        </div>
        <div class="user-list" id="userList">
            <div style="text-align: center; padding: 20px; color: #94a3b8;">
                <i class="fas fa-spinner fa-spin"></i> Loading users...
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-btn active" id="speakerBtn"><div class="icon-circle"><i class="fas fa-volume-up"></i></div><span>Speaker</span></button>
        <button class="control-btn" id="micBtn"><div class="icon-circle"><i class="fas fa-microphone-slash" id="micIcon"></i></div><span id="micText">Unmute</span></button>
        <button class="control-btn btn-red" id="leaveBtn"><div class="icon-circle"><i class="fas fa-phone-slash"></i></div><span>Leave</span></button>
    </div>

    <script>
        class SignalingServer {
            constructor() {
                this.ws = null;
                this.reconnectInterval = 3000;
                this.messageHandlers = {};
                this.myId = null;
                this.connected = false;
            }
            
            connect() {
                return new Promise((resolve, reject) => {
                    try {
                        // Public WebSocket server ব্যবহার করুন
                        const wsUrl = 'wss://ws.postman-echo.com/raw';
                        // Alternative servers:
                        // wss://echo.websocket.org
                        // wss://ws.postman-echo.com/raw
                        
                        this.ws = new WebSocket(wsUrl);
                        
                        this.ws.onopen = () => {
                            console.log('✅ WebSocket connected');
                            this.connected = true;
                            this.myId = 'User_' + Math.floor(Math.random() * 9000 + 1000);
                            document.getElementById('connectionStatus').innerHTML = 
                                `<span style="color: #10b981;">Connected as ${this.myId}</span>`;
                            resolve(this.myId);
                        };
                        
                        this.ws.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                this.handleMessage(data);
                            } catch (e) {
                                console.log('Raw message:', event.data);
                            }
                        };
                        
                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            document.getElementById('connectionStatus').innerHTML = 
                                `<span style="color: #ef4444;">Connection error</span>`;
                        };
                        
                        this.ws.onclose = () => {
                            console.log('WebSocket disconnected');
                            this.connected = false;
                            document.getElementById('connectionStatus').innerHTML = 
                                `<span style="color: #ef4444;">Disconnected - Reconnecting...</span>`;
                            setTimeout(() => this.connect(), this.reconnectInterval);
                        };
                        
                    } catch (error) {
                        reject(error);
                    }
                });
            }
            
            send(type, data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const message = JSON.stringify({ type, ...data, sender: this.myId });
                    this.ws.send(message);
                }
            }
            
            on(type, handler) {
                this.messageHandlers[type] = handler;
            }
            
            handleMessage(data) {
                if (data.type && this.messageHandlers[data.type]) {
                    this.messageHandlers[data.type](data);
                }
            }
        }

        class VoiceChat {
            constructor() {
                this.signaling = new SignalingServer();
                this.myId = null;
                this.localStream = null;
                this.peers = {};
                this.users = {};
                this.audioElements = {};
                this.isMuted = true;
                
                this.init();
            }
            
            async init() {
                try {
                    // Get microphone access
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    // Start muted
                    this.localStream.getAudioTracks()[0].enabled = false;
                    
                    // Connect to signaling server
                    this.myId = await this.signaling.connect();
                    
                    // Setup message handlers
                    this.setupHandlers();
                    
                    // Send join message
                    this.signaling.send('join', {
                        id: this.myId,
                        isMuted: this.isMuted
                    });
                    
                    // Setup UI
                    this.setupUI();
                    
                    // Periodically send heartbeat
                    setInterval(() => {
                        if (this.signaling.connected) {
                            this.signaling.send('heartbeat', {
                                id: this.myId,
                                isMuted: this.isMuted
                            });
                        }
                    }, 5000);
                    
                    console.log('Voice chat initialized:', this.myId);
                    
                } catch (error) {
                    console.error('Initialization error:', error);
                    alert('Microphone access required for voice chat!');
                }
            }
            
            setupHandlers() {
                // Handle user joined
                this.signaling.on('user-joined', (data) => {
                    if (data.id !== this.myId) {
                        this.addUser(data.id, data.isMuted);
                        this.connectToUser(data.id);
                    }
                });
                
                // Handle user left
                this.signaling.on('user-left', (data) => {
                    this.removeUser(data.id);
                });
                
                // Handle user list
                this.signaling.on('user-list', (data) => {
                    this.updateUserList(data.users);
                });
                
                // Handle offer signal
                this.signaling.on('offer', (data) => {
                    this.handleOffer(data.from, data.signal);
                });
                
                // Handle answer signal
                this.signaling.on('answer', (data) => {
                    this.handleAnswer(data.from, data.signal);
                });
                
                // Handle ICE candidate
                this.signaling.on('ice-candidate', (data) => {
                    this.handleICECandidate(data.from, data.candidate);
                });
                
                // Handle user update
                this.signaling.on('user-update', (data) => {
                    this.updateUser(data.id, data.isMuted);
                });
            }
            
            setupUI() {
                // Mic button
                document.getElementById('micBtn').onclick = () => {
                    if (!this.localStream) return;
                    
                    const audioTrack = this.localStream.getAudioTracks()[0];
                    this.isMuted = !audioTrack.enabled;
                    audioTrack.enabled = !this.isMuted;
                    
                    // Update UI
                    document.getElementById('micBtn').classList.toggle('active', !this.isMuted);
                    document.getElementById('micIcon').className = this.isMuted ? 
                        'fas fa-microphone-slash' : 'fas fa-microphone';
                    document.getElementById('micText').innerText = this.isMuted ? 'Unmute' : 'Mute';
                    
                    // Broadcast mute status
                    this.signaling.send('user-update', {
                        id: this.myId,
                        isMuted: this.isMuted
                    });
                    
                    this.updateUI();
                };
                
                // Speaker button
                document.getElementById('speakerBtn').onclick = () => {
                    const btn = document.getElementById('speakerBtn');
                    const isActive = btn.classList.contains('active');
                    
                    if (isActive) {
                        btn.classList.remove('active');
                        document.querySelector('#speakerBtn .icon-circle i').className = 'fas fa-volume-mute';
                        
                        // Mute all remote audio
                        Object.values(this.audioElements).forEach(audio => {
                            audio.volume = 0;
                        });
                    } else {
                        btn.classList.add('active');
                        document.querySelector('#speakerBtn .icon-circle i').className = 'fas fa-volume-up';
                        
                        // Unmute all remote audio
                        Object.values(this.audioElements).forEach(audio => {
                            audio.volume = 1.0;
                        });
                    }
                };
                
                // Leave button
                document.getElementById('leaveBtn').onclick = () => {
                    if (confirm('Are you sure you want to leave?')) {
                        this.leaveRoom();
                        location.reload();
                    }
                };
            }
            
            addUser(userId, isMuted) {
                if (!this.users[userId]) {
                    this.users[userId] = {
                        id: userId,
                        isMuted: isMuted || true,
                        connected: false
                    };
                    this.updateUI();
                }
            }
            
            removeUser(userId) {
                // Cleanup peer connection
                if (this.peers[userId]) {
                    this.peers[userId].destroy();
                    delete this.peers[userId];
                }
                
                // Cleanup audio element
                if (this.audioElements[userId]) {
                    this.audioElements[userId].pause();
                    this.audioElements[userId].srcObject = null;
                    this.audioElements[userId].remove();
                    delete this.audioElements[userId];
                }
                
                // Remove from users list
                delete this.users[userId];
                this.updateUI();
            }
            
            updateUser(userId, isMuted) {
                if (this.users[userId]) {
                    this.users[userId].isMuted = isMuted;
                    this.updateUI();
                }
            }
            
            updateUserList(users) {
                this.users = {};
                users.forEach(user => {
                    if (user.id !== this.myId) {
                        this.users[user.id] = user;
                    }
                });
                this.updateUI();
            }
            
            connectToUser(userId) {
                if (this.peers[userId] || userId === this.myId) return;
                
                console.log('Connecting to:', userId);
                
                const peer = new SimplePeer({
                    initiator: true,
                    trickle: true,
                    stream: this.localStream,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' }
                        ]
                    }
                });
                
                peer.on('signal', (signal) => {
                    this.signaling.send('offer', {
                        to: userId,
                        signal: signal
                    });
                });
                
                peer.on('stream', (stream) => {
                    this.handleRemoteStream(userId, stream);
                });
                
                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    this.removeUser(userId);
                });
                
                peer.on('close', () => {
                    this.removeUser(userId);
                });
                
                this.peers[userId] = peer;
            }
            
            handleOffer(fromUserId, signal) {
                if (this.peers[fromUserId]) return;
                
                console.log('Received offer from:', fromUserId);
                
                const peer = new SimplePeer({
                    initiator: false,
                    trickle: true,
                    stream: this.localStream,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' }
                        ]
                    }
                });
                
                peer.on('signal', (answerSignal) => {
                    this.signaling.send('answer', {
                        to: fromUserId,
                        signal: answerSignal
                    });
                });
                
                peer.on('stream', (stream) => {
                    this.handleRemoteStream(fromUserId, stream);
                });
                
                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    this.removeUser(fromUserId);
                });
                
                peer.signal(signal);
                this.peers[fromUserId] = peer;
            }
            
            handleAnswer(fromUserId, signal) {
                const peer = this.peers[fromUserId];
                if (peer) {
                    peer.signal(signal);
                }
            }
            
            handleICECandidate(fromUserId, candidate) {
                const peer = this.peers[fromUserId];
                if (peer && candidate) {
                    peer.addIceCandidate(new RTCIceCandidate(candidate));
                }
            }
            
            handleRemoteStream(userId, stream) {
                console.log('Received stream from:', userId);
                
                let audio = this.audioElements[userId];
                if (!audio) {
                    audio = document.createElement('audio');
                    audio.id = 'audio-' + userId;
                    audio.autoplay = true;
                    audio.volume = 1.0;
                    document.body.appendChild(audio);
                    this.audioElements[userId] = audio;
                }
                
                audio.srcObject = stream;
                
                // Update user connection status
                if (this.users[userId]) {
                    this.users[userId].connected = true;
                    this.updateUI();
                }
            }
            
            updateUI() {
                const userList = document.getElementById('userList');
                const userCount = document.getElementById('userCount');
                
                // Add myself to the list
                const allUsers = {
                    [this.myId]: {
                        id: this.myId,
                        isMuted: this.isMuted,
                        connected: true
                    },
                    ...this.users
                };
                
                const usersArray = Object.values(allUsers);
                const onlineCount = usersArray.length;
                
                userCount.textContent = `${onlineCount} Online`;
                
                let html = '';
                usersArray.forEach(user => {
                    const isMe = user.id === this.myId;
                    const isSpeaking = !user.isMuted && user.connected;
                    
                    html += `
                        <div class="user-card">
                            <div class="avatar ${isSpeaking ? 'voice-active' : ''}">
                                <i class="fas fa-user"></i>
                            </div>
                            <div>
                                <strong>${isMe ? 'You (Me)' : user.id}</strong><br>
                                <span class="status-badge ${user.connected ? 'connected' : 'disconnected'}">
                                    ${user.connected ? 'Connected' : 'Connecting'}
                                </span>
                                <span class="status-badge ${isSpeaking ? 'speaking' : 'muted'}">
                                    ${isSpeaking ? 'Speaking' : 'Muted'}
                                </span>
                            </div>
                        </div>
                    `;
                });
                
                userList.innerHTML = html || '<div style="text-align: center; padding: 20px; color: #94a3b8;">No users online</div>';
            }
            
            leaveRoom() {
                // Send leave message
                this.signaling.send('leave', { id: this.myId });
                
                // Cleanup all peers
                Object.keys(this.peers).forEach(userId => {
                    this.removeUser(userId);
                });
                
                // Stop local stream
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }
                
                // Close WebSocket
                if (this.signaling.ws) {
                    this.signaling.ws.close();
                }
            }
        }

        // Start the voice chat when page loads
        window.addEventListener('load', () => {
            new VoiceChat();
        });
    </script>
</body>
    </html>
